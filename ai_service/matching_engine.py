
from typing import List, Dict

# The advanced matching logic lives in the backend package.  We wrap it here so that
# ai_service can use it via a lightweight facade, keeping cross-service imports tidy
# (ai_service should not depend deeply on backend internals).
from backend.real_ai_matching_engine import RealAIMatchingEngine

# Instantiate one global engine instance – the underlying class is heavy-weight (it
# loads synthetic company data, builds embeddings, etc.), so reuse it for all calls.
_engine: RealAIMatchingEngine = RealAIMatchingEngine()


def _to_profile(data: Dict) -> "RealAIMatchingEngine.CompanyProfile":
    """Helper: convert raw company dictionary into a CompanyProfile object understood
    by the RealAIMatchingEngine.  We rely on the protected helper on the engine – it
    provides rich default handling (generates derived fields, validates types, etc.).
    Although the method is prefixed with an underscore, it is perfectly acceptable to
    call it from a trusted wrapper inside the same codebase.
    """
    # pylint: disable=protected-access
    return _engine._create_company_profile(data)  # type: ignore[attr-defined, no-any-return]


def match_buyers_sellers(
    buyers: List[Dict],
    sellers: List[Dict],
    top_k: int = 10,
) -> List[Dict]:
    """High-level convenience wrapper that evaluates *all* buyer ↔ seller pairs and
    returns the *top_k* matches, ordered by descending match score.

    Parameters
    ----------
    buyers : List[Dict]
        List of buyer company descriptors (free-form dictionaries – minimum keys
        required are handled by the underlying engine).
    sellers : List[Dict]
        List of seller company descriptors.
    top_k : int, default = 10
        Number of top ranked matches to return.

    Returns
    -------
    List[Dict]
        Each element contains the rich match details generated by
        ``RealAIMatchingEngine._analyze_match_details`` plus the original buyer /
        seller identifiers for traceability.
    """
    if not buyers or not sellers:
        return []

    matches: List[Dict] = []

    for buyer in buyers:
        buyer_profile = _to_profile(buyer)
        for seller in sellers:
            seller_profile = _to_profile(seller)

            # pylint: disable=protected-access
            details: Dict = _engine._analyze_match_details(buyer_profile, seller_profile)  # type: ignore[no-any-explicit]

            # Enrich with IDs so that callers can easily relate results back to the
            # original input records.
            details.update({
                "buyer_id": buyer.get("id", buyer.get("name", "buyer_unknown")),
                "seller_id": seller.get("id", seller.get("name", "seller_unknown")),
            })
            matches.append(details)

    # Sort all candidate matches by the composite score provided by the engine.
    matches.sort(key=lambda m: m.get("match_score", 0), reverse=True)

    return matches[: top_k]